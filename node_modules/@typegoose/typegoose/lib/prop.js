"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapProp = exports.ArrayProp = exports.Prop = exports.mapProp = exports.arrayProp = exports.prop = exports._buildPropMetadata = void 0;
const mongoose = require("mongoose");
const util_1 = require("util");
const constants_1 = require("./internal/constants");
const data_1 = require("./internal/data");
const errors_1 = require("./internal/errors");
const utils = require("./internal/utils");
const logSettings_1 = require("./logSettings");
const typegoose_1 = require("./typegoose");
/**
 * Base Function for prop & arrayProp
 * @param input All the options needed for prop's
 */
function baseProp(input) {
    const { Type, key, origOptions, target, whatis } = input;
    if (Type === target.constructor) {
        // prevent "infinite" buildSchema loop / Maximum Stack size exceeded
        throw new TypeError('It seems like the type used is the same as the target class, which is currently not supported\n' +
            `Please look at https://github.com/typegoose/typegoose/issues/42 for more information, for now please avoid using it!`);
    }
    const existingMapForTarget = Reflect.getOwnMetadata(constants_1.DecoratorKeys.PropCache, target);
    if (utils.isNullOrUndefined(existingMapForTarget)) {
        Reflect.defineMetadata(constants_1.DecoratorKeys.PropCache, new Map(), target);
    }
    const mapForTarget = existingMapForTarget !== null && existingMapForTarget !== void 0 ? existingMapForTarget : Reflect.getOwnMetadata(constants_1.DecoratorKeys.PropCache, target);
    mapForTarget.set(key, { origOptions, Type, target, key, whatis });
    logSettings_1.logger.debug('Added "%s.%s" to the Decorator Cache', utils.getName(target.constructor), key);
}
/**
 * Function that is the actual processing of the prop's (used for caching)
 * @param input All the options needed for prop's
 */
function _buildPropMetadata(input) {
    var _a;
    let { Type } = input;
    const { key, origOptions, target, whatis } = input;
    const rawOptions = Object.assign({}, origOptions);
    logSettings_1.logger.debug('Starting to process "%s.%s"', utils.getName(target), key);
    if (!utils.isNullOrUndefined(rawOptions.type)) {
        logSettings_1.logger.info('Prop Option "type" is set to', rawOptions.type);
        Type = utils.getType(rawOptions.type);
        delete rawOptions.type;
    }
    if (utils.isNotDefined(Type)) {
        typegoose_1.buildSchema(Type);
    }
    const name = utils.getName(target);
    // allow setting the type asynchronously
    if (!utils.isNullOrUndefined(rawOptions.ref)) {
        rawOptions.ref = utils.getType(rawOptions.ref);
        utils.assertion(!utils.isNullOrUndefined(rawOptions.ref), new Error(util_1.format('Option "ref" for "%s.%s" was defined with an arrow-function, but the function returned null/undefined!', name, key)));
        rawOptions.ref = typeof rawOptions.ref === 'string' ? rawOptions.ref : utils.getName(rawOptions.ref);
    }
    if (utils.isWithVirtualPOP(rawOptions)) {
        if (!utils.includesAllVirtualPOP(rawOptions)) {
            throw new errors_1.NotAllVPOPElementsError(name, key);
        }
        const virtuals = new Map((_a = Reflect.getMetadata(constants_1.DecoratorKeys.VirtualPopulate, target.constructor)) !== null && _a !== void 0 ? _a : []);
        virtuals.set(key, rawOptions);
        Reflect.defineMetadata(constants_1.DecoratorKeys.VirtualPopulate, virtuals, target.constructor);
        return;
    }
    const schemaProp = utils.initProperty(name, key, whatis);
    if (!utils.isNullOrUndefined(rawOptions.set) || !utils.isNullOrUndefined(rawOptions.get)) {
        utils.assertion(typeof rawOptions.set === 'function', new TypeError(`"${name}.${key}" does not have a set function!`));
        utils.assertion(typeof rawOptions.get === 'function', new TypeError(`"${name}.${key}" does not have a get function!`));
        /*
         * Note:
         * this doesn't have a check if prop & returntype of the function is the same,
         * because it can't be accessed at runtime
         */
        schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), { type: Type }), rawOptions);
        return;
    }
    // use "Type" if it is an suitable ref-type, otherwise default back to "ObjectId"
    const refType = utils.isAnRefType(Type) ? Type : mongoose.Schema.Types.ObjectId;
    if ('ref' in rawOptions) {
        utils.assertion(!utils.isNullOrUndefined(rawOptions.ref), new Error(util_1.format('Options "ref" is set, but is undefined/null! (%s.%s)', name, key)));
        const ref = rawOptions.ref;
        delete rawOptions.ref;
        switch (whatis) {
            case constants_1.WhatIsIt.ARRAY:
                schemaProp[key] = utils.createArrayFromDimensions(rawOptions, Object.assign(Object.assign(Object.assign({}, schemaProp[key][0]), { type: refType, ref }), rawOptions), name, key);
                break;
            case constants_1.WhatIsIt.NONE:
                schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), { type: refType, ref }), rawOptions);
                break;
            default:
                throw new TypeError(util_1.format('"ref" is not supported for "%s"! (%s, %s)', whatis, utils.getName(target), key));
        }
        return;
    }
    const refPath = rawOptions.refPath;
    if (refPath) {
        utils.assertion(typeof refPath === 'string', new TypeError(util_1.format('"refPath" for "%s, %s" should be of type String!', utils.getName(target), key)));
        delete rawOptions.refPath;
        switch (whatis) {
            case constants_1.WhatIsIt.ARRAY:
                schemaProp[key] = utils.createArrayFromDimensions(rawOptions, Object.assign(Object.assign(Object.assign({}, schemaProp[key][0]), { type: refType, refPath }), rawOptions), name, key);
                break;
            case constants_1.WhatIsIt.NONE:
                schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), { type: refType, refPath }), rawOptions);
                break;
            default:
                throw new TypeError(util_1.format('"refPath" is not supported for "%s"! (%s, %s)', whatis, utils.getName(target), key));
        }
        return;
    }
    const enumOption = rawOptions.enum;
    if (!utils.isNullOrUndefined(enumOption)) {
        // check if the supplied value is already "mongoose-consumeable"
        if (!Array.isArray(enumOption)) {
            if (Type === String || Type === mongoose.Schema.Types.String) {
                rawOptions.enum = Object.entries(enumOption) // get all key-value pairs of the enum
                    // no reverse-filtering because if it is full of strings, there is no reverse mapping
                    .map(([enumKey, enumValue]) => {
                    // convert key-value pairs to an mongoose-usable enum
                    // safeguard, this should never happen because TypeScript only sets "design:type" to "String"
                    // if the enum is full of strings
                    if (typeof enumValue !== 'string') {
                        throw new errors_1.NotStringTypeError(name, key, enumKey, typeof enumValue);
                    }
                    return enumValue;
                });
            }
            else if (Type === Number || Type === mongoose.Schema.Types.Number) {
                rawOptions.enum = Object.entries(enumOption) // get all key-value pairs of the enum
                    // filter out the "reverse (value -> name) mappings"
                    // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings
                    .filter(([enumKey, enumValue], _i, arr) => {
                    // safeguard, this should never happen because typescript only sets "design:type" to "Number"
                    // if the enum is full of numbers
                    if (utils.isNullOrUndefined(enumValue) || arr.findIndex(([k]) => k === enumValue.toString()) <= -1) {
                        // if there is no reverse mapping, throw an error
                        throw new errors_1.NotNumberTypeError(name, key, enumKey, typeof enumValue);
                    }
                    return typeof enumValue === 'number';
                })
                    .map(([enumKey, enumValue]) => {
                    // convert key-value pairs to an mongoose-useable enum
                    if (typeof enumValue !== 'number') {
                        throw new errors_1.NotNumberTypeError(name, key, enumKey, typeof enumValue);
                    }
                    return enumValue;
                });
            }
            else {
                // this will happen if the enum type is not "String" or "Number"
                // most likely this error happened because the code got transpiled with babel or "tsc --transpile-only"
                throw new Error(`Invalid type used for map!, got: "${Type}" (${name}.${key})`
                    + 'Is the code transpiled with Babel or \'tsc --transpile-only\' or \'ts-node --transpile-only\'?\n'
                    + 'See https://typegoose.github.io/typegoose/docs/decorators/prop/#enum');
            }
        }
    }
    if (!utils.isNullOrUndefined(rawOptions.addNullToEnum)) {
        rawOptions.enum = Array.isArray(rawOptions.enum) ? rawOptions.enum : [];
        rawOptions.enum.push(null);
        delete rawOptions.addNullToEnum;
    }
    {
        // check if Type is actually a real working Type
        if (utils.isNullOrUndefined(Type) || typeof Type !== 'function') {
            throw new errors_1.InvalidTypeError(utils.getName(target), key, Type);
        }
        // check for validation inconsistencies
        if (utils.isWithStringValidate(rawOptions) && !utils.isString(Type)) {
            throw new errors_1.NotStringTypeError(name, key);
        }
        // check for transform inconsistencies
        if (utils.isWithStringTransform(rawOptions) && !utils.isString(Type)) {
            throw new errors_1.NotStringTypeError(name, key);
        }
        if (utils.isWithNumberValidate(rawOptions) && !utils.isNumber(Type)) {
            throw new errors_1.NotNumberTypeError(name, key);
        }
    }
    /** Is this Type (/Class) in the schemas Map? */
    const isInSchemas = data_1.schemas.has(utils.getName(Type));
    if (!isInSchemas && !utils.isPrimitive(Type) && !utils.isObject(Type)) {
        throw new errors_1.InvalidPropError(Type.name, key); // This seems to be never thrown!
    }
    if (utils.isPrimitive(Type)) {
        if (utils.isObject(Type, true)) {
            utils.warnMixed(target, key);
        }
        switch (whatis) {
            case constants_1.WhatIsIt.ARRAY:
                schemaProp[key] = Object.assign(Object.assign({}, schemaProp[key][0]), utils.mapArrayOptions(rawOptions, Type, target, key));
                return;
            case constants_1.WhatIsIt.MAP:
                const mapped = utils.mapOptions(rawOptions, Type, target, key, true);
                schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), mapped.outer), { type: Map, of: Object.assign({ type: Type }, mapped.inner) });
                return;
            case constants_1.WhatIsIt.NONE:
                schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), rawOptions), { type: Type });
                return;
            default:
                throw new Error(`"${whatis}"(whatis(primitive)) is invalid for "${name}.${key}"`);
        }
    }
    // If the 'Type' is not a 'Primitive Type' and no subschema was found treat the type as 'Object'
    // so that mongoose can store it as nested document
    if (utils.isObject(Type) && !isInSchemas) {
        utils.warnMixed(target, key);
        logSettings_1.logger.warn('if someone can see this message, please open an new issue at https://github.com/typegoose/typegoose/issues with reproduction code for tests');
        schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), rawOptions), { type: mongoose.Schema.Types.Mixed });
        return;
    }
    const virtualSchema = typegoose_1.buildSchema(Type);
    switch (whatis) {
        case constants_1.WhatIsIt.ARRAY:
            schemaProp[key] = Object.assign(Object.assign({}, schemaProp[key][0]), utils.mapArrayOptions(rawOptions, virtualSchema, target, key, Type));
            return;
        case constants_1.WhatIsIt.MAP:
            const mapped = utils.mapOptions(rawOptions, virtualSchema, target, key, false, Type);
            schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), mapped.outer), { type: Map, of: Object.assign({ type: virtualSchema }, mapped.inner) });
            return;
        case constants_1.WhatIsIt.NONE:
            schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), rawOptions), { type: virtualSchema });
            return;
        default:
            throw new Error(`"${whatis}"(whatis(subSchema)) is invalid for "${name}.${key}"`);
    }
}
exports._buildPropMetadata = _buildPropMetadata;
/**
 * Set Property Options for the property below
 * @param options Options
 * @param kind Overwrite auto-inferred kind
 * @example
 * ```ts
 * class ClassName {
 *   @prop()
 *   public someprop: string;
 * }
 * ```
 */
function prop(options, kind) {
    return (target, key) => {
        let Type = Reflect.getMetadata(constants_1.DecoratorKeys.Type, target, key);
        utils.assertion(!utils.isNullOrUndefined(Type), new errors_1.NoMetadataError(key));
        options = options !== null && options !== void 0 ? options : {};
        if (utils.isNullOrUndefined(kind)) {
            if (Type === Array ||
                Type === mongoose.Types.Array ||
                Type === mongoose.Schema.Types.Array ||
                Type === mongoose.Types.DocumentArray ||
                Type === mongoose.Schema.Types.DocumentArray) {
                kind = constants_1.WhatIsIt.ARRAY;
            }
            else if (Type === Map || Type === mongoose.Types.Map || Type === mongoose.Schema.Types.Map) {
                kind = constants_1.WhatIsIt.MAP;
            }
            else {
                kind = constants_1.WhatIsIt.NONE;
            }
        }
        if ('refType' in options) {
            options.type = options.refType;
            delete options.refType;
        }
        // soft errors & "type"-alias mapping
        switch (kind) {
            case constants_1.WhatIsIt.NONE:
                if ('items' in options) {
                    logSettings_1.logger.warn('You might not want to use option "items" for an non-array @prop type (%s.%s)', utils.getName(target), key);
                }
                if ('of' in options) {
                    logSettings_1.logger.warn('You might not want to use option "of" for an non-map @prop type (%s.%s)', utils.getName(target), key);
                }
                break;
            case constants_1.WhatIsIt.ARRAY:
                if ('items' in options) {
                    options.type = options.items;
                    delete options.items;
                }
                if ('of' in options) {
                    logSettings_1.logger.warn('You might not want to use option "of" where the "design:type" is "Array" (%s.%s)', utils.getName(target), key);
                }
                // set the "Type" to undefined, if "ref" or "refPath" are defined, otherwise the "refType" will be wrong
                if ((('ref' in options) || ('refPath' in options)) && !('type' in options)) {
                    Type = undefined;
                }
                break;
            case constants_1.WhatIsIt.MAP:
                if ('of' in options) {
                    options.type = options.of;
                    delete options.of;
                }
                if ('items' in options) {
                    logSettings_1.logger.warn('You might not want to use option "items" where the "design:type" is "Map" (%s.%s)', utils.getName(target), key);
                }
                break;
        }
        baseProp({
            Type,
            key,
            origOptions: options,
            target,
            whatis: kind
        });
    };
}
exports.prop = prop;
exports.Prop = prop;
/**
 * Set Property(that are Maps) Options for the property below
 * @param options Options for the Map
 *
 * @deprecated use "prop"
 */
function mapProp(options) {
    return prop(options, constants_1.WhatIsIt.MAP);
}
exports.mapProp = mapProp;
exports.MapProp = mapProp;
/**
 * Set Property(that are Arrays) Options for the property below
 * @param options Options
 *
 * @deprecated use "prop"
 */
function arrayProp(options) {
    return prop(options, constants_1.WhatIsIt.ARRAY);
}
exports.arrayProp = arrayProp;
exports.ArrayProp = arrayProp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm9wLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUFxQztBQUNyQywrQkFBOEI7QUFFOUIsb0RBQStEO0FBQy9ELDBDQUEwQztBQUMxQyw4Q0FPMkI7QUFDM0IsMENBQTBDO0FBQzFDLCtDQUF1QztBQUN2QywyQ0FBMEM7QUFjMUM7OztHQUdHO0FBQ0gsU0FBUyxRQUFRLENBQUMsS0FBZ0M7SUFDaEQsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUM7SUFDekQsSUFBSSxJQUFJLEtBQUssTUFBTSxDQUFDLFdBQVcsRUFBRTtRQUMvQixvRUFBb0U7UUFDcEUsTUFBTSxJQUFJLFNBQVMsQ0FDakIsaUdBQWlHO1lBQ2pHLHNIQUFzSCxDQUN2SCxDQUFDO0tBQ0g7SUFFRCxNQUFNLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMseUJBQWEsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFpQyxDQUFDO0lBQ3JILElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDLG9CQUFvQixDQUFDLEVBQUU7UUFDakQsT0FBTyxDQUFDLGNBQWMsQ0FBQyx5QkFBYSxDQUFDLFNBQVMsRUFBRSxJQUFJLEdBQUcsRUFBcUMsRUFBRSxNQUFNLENBQUMsQ0FBQztLQUN2RztJQUNELE1BQU0sWUFBWSxHQUFHLG9CQUFvQixhQUFwQixvQkFBb0IsY0FBcEIsb0JBQW9CLEdBQUssT0FBTyxDQUFDLGNBQWMsQ0FBQyx5QkFBYSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQWtDLENBQUM7SUFFdkksWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUVsRSxvQkFBTSxDQUFDLEtBQUssQ0FB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